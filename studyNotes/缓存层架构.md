## 旁路缓存模式
### 介绍
读取缓存，读取数据库，更新缓存都是在应用程序完成的，常用的策略。
### 执行流程
接收到请求，从缓存中读取数据，不存在则查询数据库，返回时存入缓存，返回响应。
可以使用饿汉模式/懒汉模式
### 数据一致性保障
- 更新数据库，更新缓存。ab双线程更新完数据库后，不保证更改缓存的顺序，可能有脏数据。
- 先删除缓存，再更新数据库。（更新缓存可能导致不一致）a删除缓存后，b线程查询数据库写入缓存，a更新数据库。造成了脏数据问题
- 更新数据库，再删缓存。a线程在更新数据库时，b线程读取缓存，a删除缓存。期间存在数据不一致问题。删除失败则会造成长时间不一致。
- 延迟双删。先删除缓存，更新数据库，再删除缓存。在操作1，2时可能出现数据不一致但时间不会过长，且存在兜底操作。缺点：写操作对redis有一定压力，二次删除失败则不一致时间=过期时间。
- 先更新数据库，再基于队列删除缓存。
	- 基于内存队列删除缓存。更新mysql，删除缓存任务放入队列。在删除完成之前会出现不一致，且任务队列会多次重试直到成功。
	- 基于消息队列删除缓存。与内存不同的是，避免了jvm崩溃导致的消息丢失，增加了缓存删除可靠性（消费失败进入死信队列）
	- 基于binlog+消息队列删除缓存。canal采集mysql的binlog日志，并将日志发送到队列中，消费者可以筛选类型日志，解析后执行对应的删除操作。通过消息队列的ack机制保证缓存删除。
基于队列的删除与延迟双删的区别：
- 优点：
	1. 延迟双删有2次删除操作，对redis有一定的写负担。基于队列删除只有一次，写压力小一半。
	2. 延迟双删如果失败没有引入重试策略，基于消息队列的删除则会多次尝试确保删除，如果多次失败，进入死信队列，执行运维警告
	3. 延迟双删将更新数据库与删除缓存进行耦合，没有单一职责，基于消息队列则解耦合
- 缺点：
	1. 如果写操作较多，则队列任务就会比较多。消费会变慢，需要引入多线程消费。
	2. 程序复杂度提升，引入消息队列和线程消费，需要不断进行性能优化。
	3. 内存队列是jvm进程的内部队列，如果jvm崩溃则会出现消息丢失，会出现数据不一致。
## 读写穿透
### 介绍
服务不直接与缓存数据库打交道，封装一层，通过cacheProvider执行旁路缓存。
与旁路缓存不同的一点是 写入缓存，而旁路则是删除缓存。
### 执行流程
接收到请求，从cacheprivoder获取数据，cacheprivoder从缓存获取（不存在则查询数据库并写入缓存），返回响应。
写入时同步写入缓存与数据库。
### 适用场景
写操作多，数据一致性要求高（性能差，更新数据更新缓存都需要同步，都要使用分布式锁）银行系统会使用。
## 异步写回模式
### 介绍
由cachePrivoder负责缓存和数据库读写。写入时，异步回血模式只更新缓存，不同步更新数据库，而异步批量的写入数据库，读写穿透则是同步更新缓存+数据库。
### 执行流程
接收到请求，从cacheprivoder获取数据，cacheprivoder从缓存获取（不存则查询数据库，写入缓存）返回响应。
写入时，写入缓存，当服务压力较小时，批量写入数据库。
### 适用场景
适合数据频繁变化，且对数据一致性要求不高的场景，如浏览量，点赞数。

## 三大模式比较
- 旁路缓存实现简单，但是需要维护2套数据存储。
- 读写穿透应用程序与cacheprivoder配合使用，简化了应用开发，但是cacheprivoder的实现比较复杂。
- 异步回写与读写穿透 区别是异步回写模式的数据持久化是异步的，而读写穿透的数据持久化是同步的。
- 异步回写模式优点速度快，直接操作缓存，多次更新数据合并后持久化到数据库，缺点数据可能丢失，例如系统断电。