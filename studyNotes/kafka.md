# Kafka
## 应用场景
1. 构造实时流数据管道，它可以在系统或应用之间可靠地获取数据 (相当于message queue)，特别是在集群情况下，多个服务器需要建立交流
2. 构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)
## 架构
**Producer**：生产者可以将数据发布到所选择的topic（主题）中。生成者负责将记录分配到topic的哪一个分区（partition）中，这里可以使用对多个partition循环发送来实现多个server负载均衡
**Broker**：日志的分区（partition）分布在Kafka集群的服务器上，每个服务器处理数据和请求时，共享这些分区。每一个分区都会在以配置的服务器上进行备份，确保容错性。一台server作为leader，leader用来写请求，follwos用来同步备份，当leader宕机时，切换为follows
**Consumer**：消费者使用一个group（消费组）名称来表示，发布到topic中的每条记录将被分配到订阅消费组中的其中一个消费者示例。消费者实例可以分布在多个进程中或多个机器上
## 持久化存储

1. 摒弃jvm堆缓存以及随机读写。kafka使用**文件系统和页缓存**处理数据，而非在进程中对数据进行缓存
1. 页缓存：在消息发送后，并没有等到消息写入磁盘后才返回，而是到page Cache中就返回。page Cache与文件系统的写入由操作系统自动完成
## 高性能
1. 顺序写入：顺序写入与随机写入速度相差高达6000倍

2. 批量处理：使用消息累加器仅多个消息批量发送，既节省带宽有提高了发送速度

3. 消息压缩：kafka支持队消息压缩，支持格式有：gzip、snapply、lz4，可以使用compression.type配置
4.  零拷贝（zero-copy）：Kafka两个重要过程都使用了零拷贝技术，且都是操作系统层面的狭义零拷贝，一是Producer生产的数据存到broker，二是 Consumer从broker读取数据。
关于zero-copy：
sendfile系统调用可以将页缓存中的数据直接传输到socket。优化后只需要最后一次将数据拷贝到网卡的缓冲区中。
这种结合页缓存和sendfile方式，意味着磁盘上没有任何读取操作，因为consumer直接从缓存中获取数据。

