
## IO读写基础原理
### 操作系统底层原因
操作系统虚拟内存分为：用户空间和内核空间（保证内核安全）
内核模块运行在内核空间，用户模块（应用）运行在用户空间。
内核程序独立于应用程序，是既可以访问内核空间又可以访问底层硬件设备。而应用程序（用户态进程）不能直接在内核区域读写，也不能直接调用内核代码定义的函数。用户态进程需要切换为内核态才能进行系统调用。
对于读写操作则需要用到底层的sys_read和sys_write两大系统调用，而对于读操作则是将内核缓冲区的数据复制到应用程序进程缓冲区，写操作则是将应用程序进程缓冲区写入到内核缓冲区。
```ad-tip
**为什么有缓冲区？**
*缓冲区的目的是为了避免频繁的与设备之间的物理交换，对内核缓冲区进行监控，等一定量的数据时，进行批量操作，提高系统效率。
减少底层系统频繁中断导致的时间损耗，性能损耗。*
```

[[Drawing 2024-04-10 20.30.04.excalidraw]]
## 5种IO模型
1. 同步阻塞IO
	用户主动发起，等待内核IO操作彻底完成后，才返回用户空间的IO操作。在IO操作时，发起请求的用户线程处于阻塞状态。
2. 同步非阻塞IO
	用户程序不需要等待内核IO操作彻底完成，可以立即返回用户空间去执行后续的指令。（需要不断的IO轮询）
3. IO多路复用
	由一个用户线程监控多个文件描述符，如果某个文件描述符准备就绪，调用系统函数，内核就能够将文件描述符的就绪状态返回给用户线程，用户空间根据相应的就绪状态进行IO系统调用。

4. 信号驱动IO模型
	用户线程通过向核心注册IO事件的回掉函数来避免IO时间查询的阻塞。只有通知阶段是异步的，而复制阶段则是同步阻塞的。
5. 异步IO
	用户线程变成被动接受者，内核空间变成主动调用者。当用户线程接收到通知时，内核已经将数据读取完成并放入用户缓冲区，用户线程直接调用即可。
